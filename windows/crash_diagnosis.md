# Windows Crash Diagnosis

Automated crash diagnosis on Windows using minidumps, cdb, and related tools. Covers the full pipeline from crash capture through analysis. Language-agnostic — works with any native code that produces `.pdb` files (C, C++, Jai, Rust, etc.).

## Quick Reference

| Task | Command |
|------|---------|
| Analyze a crash dump | `bash analyze-dump.sh <dump.dmp> [pdb-dir]` |
| Attach to hung process | `bash attach-dump.sh <exe-or-pid>` |
| Enable heap checks | `appverif -enable Heaps -for myapp.exe` |
| Check event log | `wevtutil qe Application /q:"*[System[Provider[@Name='Application Error']]]" /c:5 /f:text` |

## Concepts

### Minidumps

A `.dmp` file is a snapshot of process state — registers, stack, loaded modules, and optionally heap contents. Created by `MiniDumpWriteDump` from `dbghelp.dll`. Can be generated:

- **From an exception filter** (SEH handler) — captures the crash context
- **On demand** — from assertion handlers, test harnesses, or debug commands while the process is alive
- **By external tools** — WER (automatic), procdump, Task Manager, cdb

Dump files are analyzed offline with cdb or WinDbg. They contain enough state to reconstruct the call stack, inspect variables, and identify the faulting instruction.

### PDB Files

Symbol files generated by the compiler alongside executables. Required for meaningful stack traces (function names, source lines). Most native compilers produce these by default on Windows:

- **MSVC/cl.exe**: `/Zi` or `/ZI` flag (usually default in Debug builds)
- **Jai**: Always generates `.pdb` alongside executables
- **Rust**: Generates `.pdb` on Windows targets by default
- **Clang/LLVM**: Use `-g -gcodeview` to produce PDB-compatible debug info

Keep `.pdb` files alongside executables or in a known directory for cdb to find them.

### SEH (Structured Exception Handling)

Windows catches hardware faults (access violations, divide by zero, stack overflow) as exceptions that propagate through the SEH chain. `SetUnhandledExceptionFilter` registers a last-chance handler that runs before the process terminates. This is the standard place to write a crash dump.

## Generating Dumps In-Process

### SEH Handler Pattern

Register an unhandled exception filter at startup. When a hard crash occurs, the handler writes a dump and crash report before the process exits.

**C example:**
```c
#include <windows.h>
#include <dbghelp.h>
#pragma comment(lib, "dbghelp.lib")

LONG WINAPI crash_handler(EXCEPTION_POINTERS *ep) {
    HANDLE file = CreateFileA("crash.dmp", GENERIC_WRITE, 0, NULL,
                              CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (file != INVALID_HANDLE_VALUE) {
        MINIDUMP_EXCEPTION_INFORMATION mei;
        mei.ThreadId = GetCurrentThreadId();
        mei.ExceptionPointers = ep;
        mei.ClientPointers = FALSE;
        MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(),
                          file, MiniDumpWithDataSegs, &mei, NULL, NULL);
        CloseHandle(file);
    }
    return EXCEPTION_EXECUTE_HANDLER;
}

// At startup:
SetUnhandledExceptionFilter(crash_handler);
SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);
```

**Jai example:**
```
// Jai's SEH handlers must be #c_call. Use only Win32 APIs and fixed
// buffers — no tprint, no allocator, no push_context. See "Handler
// Safety" section below.

debug_seh_handler :: (ep: *EXCEPTION_POINTERS) -> s32 #c_call {
    // Write minidump via MiniDumpWriteDump (Win32 only)
    // Write crash report via CreateFileA/WriteFile (fixed buffer)
    return 1;  // EXCEPTION_EXECUTE_HANDLER
}

// At startup:
SetUnhandledExceptionFilter(debug_seh_handler);
SetErrorMode(.SEM_FAILCRITICALERRORS | .SEM_NOGPFAULTERRORBOX);
```

### On-Demand Dumps

`MiniDumpWriteDump` can be called at any point while the process is alive — not just from exception filters. Useful for:

- Assertion/error handlers (capture state at the error site)
- Test harness failures (dump the specific failing case)
- Debug commands (user-triggered snapshots)

Pass `NULL` for the exception information parameter when no exception is active.

### Handler Safety

The crash handler runs in a potentially corrupted process. If the crash IS allocator corruption, any code that allocates memory (including string formatting) will double-fault, making the process appear hung.

**Rules for safe crash handlers:**

1. **No heap allocation** — no `malloc`, `tprint`, `new`, string builders, or dynamic arrays
2. **Fixed buffers only** — format into stack-allocated or global `char[N]` / `[N] u8` buffers
3. **Re-entry guard** — a global flag to detect and bail on double-faults
4. **Win32 I/O only** — `CreateFileA`/`WriteFile`/`CloseHandle`, not `fopen`/`fprintf` or language-level file I/O
5. **Minidump first** — write the dump before the crash report. If report formatting fails, you still have the dump.
6. **Keep it minimal** — the less code in the handler, the less that can go wrong

**Jai-specific constraints** for `#c_call` handlers:
- `for` loops require Jai context — use `while` loops instead
- Non-`#c_call` functions can't be called without `push_context` (which allocates)
- `defer` works in `#c_call` functions

**C-specific notes:**
- `printf`/`fprintf` may allocate internally — avoid in crash handlers
- `_snprintf` with a stack buffer is safe
- CRT functions may hold locks that caused the crash — prefer Win32 APIs

### Dump File Management

- Store dumps in a dedicated directory (e.g., `crash-dumps/`), gitignored
- Include context in filenames: `crash-seed42-depth3.dmp`, `assert-line412.dmp`
- Create the directory via `CreateDirectoryA` (ignore "already exists" error)
- `MiniDumpWithDataSegs` flag includes global variable state — valuable for game state inspection

## Analyzing Dumps with cdb

### Installation

```bash
winget install Microsoft.WinDbg
```

This installs as an MSIX package. The path changes on update. Resolve dynamically:

```bash
CDB_DIR=$(powershell -NoProfile -Command "(Get-AppxPackage *WinDbg*).InstallLocation" | tr -d '\r')
CDB="$CDB_DIR/amd64/cdb.exe"
```

### Symbol Server Setup

OS symbols are required for meaningful analysis. Without them, `!analyze -v` degrades to `WRONG_SYMBOLS` — no source lines, no bug classification, broken stack walks through system frames.

Use the Microsoft symbol server with a local cache:

```
srv*C:\symbols*https://msdl.microsoft.com/download/symbols;<pdb-directory>
```

First run downloads ~100MB (ntdll, kernel32, etc.). Cached to `C:\symbols` for subsequent runs (~3 seconds total after caching).

### Post-Mortem Analysis

Create a command script (avoids bash `!` expansion issues with `!analyze`):

```
.sympath srv*C:\symbols*https://msdl.microsoft.com/download/symbols;<pdb-dir>
.reload
!analyze -v
.ecxr
kb
q
```

Run:
```bash
"$CDB" -sins -z <dump.dmp> -cf <script.txt> 2>&1 | grep -v NatVis
```

**Key flags:**
- `-sins` — ignore symbol path environment variables (prevents stale defaults)
- `-cf <file>` — read commands from script file (avoids bash `!` expansion)
- `grep -v NatVis` — suppress noisy NatVis warnings

**Output provides:**
- Bug classification: `INVALID_POINTER_WRITE`, `HEAP_CORRUPTION`, etc.
- Faulting source file and line number
- Full annotated call stack through both application and system frames
- Exception parameters (read/write address, etc.)

### Live-Attach Analysis

For processes that appear hung (e.g., double-fault in crash handler):

```
.sympath srv*C:\symbols*https://msdl.microsoft.com/download/symbols
.reload
~*kb
.dump /ma crash-dumps/live-attach.dmp
.detach
q
```

Run by process name or PID:
```bash
"$CDB" -sins -pn myapp.exe -cf <script.txt> 2>&1 | grep -v NatVis
# or
"$CDB" -sins -p <pid> -cf <script.txt> 2>&1 | grep -v NatVis
```

- `~*kb` — all thread stacks (the primary diagnostic for hangs)
- `.dump /ma` — write a full dump for follow-up analysis
- `.detach` — detach without killing the process

### Wrapper Scripts for Claude Code

Running cdb directly requires user approval for each invocation (arguments change between runs). Wrapper scripts solve this — "allow similar" covers all invocations once approved per script.

**`analyze-dump.sh`** — post-mortem analysis:
```bash
#!/bin/bash
set -euo pipefail
DUMP="${1:?Usage: analyze-dump.sh <dump-file> [pdb-dir]}"
PDB_DIR="${2:-$(dirname "$DUMP")}"
CDB_DIR=$(powershell -NoProfile -Command \
    "(Get-AppxPackage *WinDbg*).InstallLocation" | tr -d '\r')
CDB="$CDB_DIR/amd64/cdb.exe"
PDB_DIR_WIN=$(cygpath -w "$PDB_DIR" 2>/dev/null || echo "$PDB_DIR")
SCRIPT=$(mktemp /tmp/cdb-analyze-XXXXXX.txt)
trap 'rm -f "$SCRIPT"' EXIT
cat > "$SCRIPT" <<EOF
.sympath srv*C:\\symbols*https://msdl.microsoft.com/download/symbols;$PDB_DIR_WIN
.reload
!analyze -v
.ecxr
kb
q
EOF
"$CDB" -sins -z "$DUMP" -cf "$SCRIPT" 2>&1 | grep -v NatVis
```

**`attach-dump.sh`** — live-attach:
```bash
#!/bin/bash
set -euo pipefail
TARGET="${1:?Usage: attach-dump.sh <exe-name-or-pid>}"
CDB_DIR=$(powershell -NoProfile -Command \
    "(Get-AppxPackage *WinDbg*).InstallLocation" | tr -d '\r')
CDB="$CDB_DIR/amd64/cdb.exe"
SCRIPT=$(mktemp /tmp/cdb-attach-XXXXXX.txt)
trap 'rm -f "$SCRIPT"' EXIT
TIMESTAMP=$(date +%Y%m%d-%H%M%S)
mkdir -p crash-dumps
cat > "$SCRIPT" <<EOF
.sympath srv*C:\\symbols*https://msdl.microsoft.com/download/symbols
.reload
~*kb
.dump /ma crash-dumps/hang-${TIMESTAMP}.dmp
.detach
q
EOF
if [[ "$TARGET" =~ ^[0-9]+$ ]]; then
    "$CDB" -sins -p "$TARGET" -cf "$SCRIPT" 2>&1 | grep -v NatVis
else
    "$CDB" -sins -pn "$TARGET" -cf "$SCRIPT" 2>&1 | grep -v NatVis
fi
```

## WER LocalDumps (Zero Code Changes)

Windows Error Reporting can automatically save minidumps for any crashing process via a registry key. No code changes required — acts as a safety net.

```
HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps\<exe-name>
    DumpFolder  REG_EXPAND_SZ  <path>\crash-dumps
    DumpType    REG_DWORD      1 (mini) or 2 (full)
    DumpCount   REG_DWORD      10
```

Configure via `reg add`:
```bash
reg add "HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps\stress_test.exe" \
    /v DumpFolder /t REG_EXPAND_SZ /d "C:\path\to\crash-dumps" /f
reg add "HKLM\SOFTWARE\Microsoft\Windows\Windows Error Reporting\LocalDumps\stress_test.exe" \
    /v DumpType /t REG_DWORD /d 2 /f
```

Per-exe keys override the global default. Useful when the in-process SEH handler itself crashes (double-fault scenario).

## Application Verifier

Already installed on most development machines. Instruments a process to detect heap corruption at the point of the bad write, rather than when the corruption is later discovered.

```bash
# Enable heap checks
appverif -enable Heaps -for myapp.exe

# Run normally — Verifier breaks into debugger at corruption point
./myapp.exe

# Disable when done
appverif -disable * -for myapp.exe
```

Heap checks add overhead but catch:
- Write-after-free
- Buffer overruns/underruns
- Double-free
- Mismatched alloc/free

Combine with cdb for best results: run under the debugger with Verifier enabled, and it breaks at the exact instruction that corrupts the heap.

## Diagnostic Workflow

### Crash (process exits)

1. Check for `.dmp` in `crash-dumps/` (from SEH handler)
2. If no dump, check WER LocalDumps location
3. Run `analyze-dump.sh <dump> <pdb-dir>`
4. Read the `STACK_TEXT`, `FAULTING_SOURCE_LINE`, and `Failure.Bucket` fields
5. Correlate with any text crash report (breadcrumb context)

### Hang (process stuck)

1. Run `attach-dump.sh <exe-or-pid>`
2. Read `~*kb` output — thread 0 is usually the interesting one
3. If thread 0 is in an exception filter, it's a double-fault (crash handler crashed)
4. Analyze the saved dump for full context

### Heap corruption (crash in allocator)

1. Crash dump shows fault in `allocate_medium`, `HeapAlloc`, `RtlAllocateHeap`, or similar
2. The corruption happened EARLIER — the crash site is where it was discovered, not where it was caused
3. Enable Application Verifier heap checks and reproduce
4. Verifier breaks at the actual bad write, giving the true root cause

### Intermittent crashes

1. Use procdump to monitor: `procdump -e -ma myapp.exe`
2. Or run a stress test that generates dumps on failure
3. Compare multiple dumps — same stack = deterministic bug, different stacks = memory corruption or race
